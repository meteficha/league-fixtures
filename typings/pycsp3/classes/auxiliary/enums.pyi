"""
This type stub file was generated by pyright.
"""

from enum import Enum, unique

def auto(n_occurrences=...): # -> Any | int | Generator[Any | int, None, None]:
    ...

@unique
class TypeFramework(Enum):
    def __str__(self) -> str:
        ...
    


class AbstractType(Enum):
    def __str__(self) -> str:
        ...
    


@unique
class TypeVar(AbstractType):
    def is_basic(self): # -> bool:
        ...
    
    def is_stochastic(self): # -> bool:
        ...
    
    def is_set(self): # -> bool:
        ...
    
    def is_graph(self): # -> bool:
        ...
    
    def is_qualitative(self): # -> bool:
        ...
    


@unique
class TypeCtr(AbstractType):
    SUBSET_ALL_DIFFERENT = ...
    DUMMY = ...
    @staticmethod
    def value_of(s): # -> TypeCtr:
        ...
    


@unique
class TypeCtrArg(AbstractType):
    MAPPING = ...
    COVERED = ...
    INTENTION = ...
    def with_compactable_values(self): # -> bool:
        ...
    


@unique
class TypeXML(AbstractType):
    INSTANCE = ...
    SOFT = ...


@unique
class TypeObj(AbstractType):
    ...


@unique
class TypeAnn(AbstractType):
    @staticmethod
    def value_of(s): # -> TypeAnn:
        ...
    


UTF_EQ = ...
UTF_NE = ...
UTF_LT = ...
UTF_LE = ...
UTF_GE = ...
UTF_GT = ...
UTF_LTGT = ...
UTF_NOT_ELEMENT_OF = ...
UTF_COMPLEMENT = ...
@unique
class TypeConditionOperator(AbstractType):
    def __invert__(self): # -> Literal[TypeConditionOperator.NE, TypeConditionOperator.EQ, TypeConditionOperator.GE, TypeConditionOperator.GT, TypeConditionOperator.LE, TypeConditionOperator.LT, TypeConditionOperator.NOTIN, TypeConditionOperator.IN] | None:
        ...
    
    def arithmetic_inversion(self): # -> Literal[TypeConditionOperator.GT, TypeConditionOperator.GE, TypeConditionOperator.LE, TypeConditionOperator.LT, TypeConditionOperator.NE, TypeConditionOperator.EQ] | None:
        ...
    
    def is_set(self): # -> bool:
        ...
    
    def is_rel(self): # -> bool:
        ...
    
    @staticmethod
    def value_of(s): # -> TypeConditionOperator:
        ...
    
    @staticmethod
    def to_utf(condition_operator): # -> Literal['﹤', '≤', '≥', '﹥', '=', '≠', '∁']:
        ...
    
    def to_str(self): # -> Literal['<', '<=', '>=', '>', '=', '!=', 'in', 'not in']:
        ...
    
    def check(self, left_operand, right_operand): # -> bool:
        ...
    


@unique
class TypeArithmeticOperator(Enum):
    ...


@unique
class TypeUnaryArithmeticOperator(Enum):
    ...


@unique
class TypeLogicalOperator(Enum):
    ...


@unique
class TypeOrderedOperator(Enum):
    @staticmethod
    def value_of(s): # -> TypeOrderedOperator:
        ...
    
    def __str__(self) -> str:
        ...
    


@unique
class TypeRank(Enum):
    def __str__(self) -> str:
        ...
    


@unique
class TypeSolver(Enum):
    ...


@unique
class TypeStatus(Enum):
    def __str__(self) -> str:
        ...
    


@unique
class TypeSquareSymmetry(Enum):
    @staticmethod
    def rotations(): # -> tuple[Literal[TypeSquareSymmetry.R090], Literal[TypeSquareSymmetry.R180], Literal[TypeSquareSymmetry.R270]]:
        ...
    
    @staticmethod
    def reflections(): # -> tuple[Literal[TypeSquareSymmetry.FX], Literal[TypeSquareSymmetry.FY], Literal[TypeSquareSymmetry.FD1], Literal[TypeSquareSymmetry.FD2]]:
        ...
    
    def is_rotation(self): # -> bool:
        ...
    
    def is_reflection(self): # -> bool:
        ...
    
    @staticmethod
    def symmetric_patterns(pattern): # -> list[Any]:
        """
        Returns all symmetric patterns (including identity) of the specified one (can be useful for computing symmetric variants of polyominoes)

        :param pattern: a pattern given as a set of relative coordinates
        :return: all symmetric patterns of the specified one
        """
        ...
    
    def apply_on(self, n):
        ...
    


@unique
class TypeRectangleSymmetry(Enum):
    @staticmethod
    def rotations(): # -> tuple[Literal[TypeRectangleSymmetry.R180]]:
        ...
    
    @staticmethod
    def reflections(): # -> tuple[Literal[TypeRectangleSymmetry.FX], Literal[TypeRectangleSymmetry.FY]]:
        ...
    
    def is_rotation(self): # -> bool:
        ...
    
    def is_reflection(self): # -> bool:
        ...
    
    def apply_on(self, n, m):
        ...
    


@unique
class TypeHexagonSymmetry(Enum):
    @staticmethod
    def rotations(): # -> tuple[Literal[TypeHexagonSymmetry.R060], Literal[TypeHexagonSymmetry.R120], Literal[TypeHexagonSymmetry.R180], Literal[TypeHexagonSymmetry.R240], Literal[TypeHexagonSymmetry.R300]]:
        ...
    
    @staticmethod
    def reflections(): # -> tuple[Literal[TypeHexagonSymmetry.L1], Literal[TypeHexagonSymmetry.L2], Literal[TypeHexagonSymmetry.L3], Literal[TypeHexagonSymmetry.L4], Literal[TypeHexagonSymmetry.L5], Literal[TypeHexagonSymmetry.L6]]:
        ...
    
    def is_rotation(self): # -> bool:
        ...
    
    def is_reflection(self): # -> bool:
        ...
    
    @staticmethod
    def ring_cells(ring): # -> list[tuple[int, int]]:
        ...
    
    def apply_on(self, n):
        ...
    


class TypeAbstractOperation(Enum):
    ...


