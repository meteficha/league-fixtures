"""
This type stub file was generated by pyright.
"""

from enum import Enum, unique
from pycsp3.classes.auxiliary.enums import TypeAbstractOperation
from pycsp3.classes.entities import Entity

@unique
class TypeNode(Enum):
    def __init__(self, node_id, min_arity, max_arity) -> None:
        ...
    
    def __invert__(self): # -> Literal[TypeNode.NE, TypeNode.EQ, TypeNode.GE, TypeNode.GT, TypeNode.LE, TypeNode.LT, TypeNode.NOTIN, TypeNode.IN] | None:
        ...
    
    def __str__(self) -> str:
        ...
    
    IF = ...
    SET = ...
    SPECIAL = ...
    def is_valid_arity(self, k):
        ...
    
    def is_symmetric_operator(self): # -> bool:
        ...
    
    def is_not_symmetric_relational_operator(self): # -> bool:
        ...
    
    def is_relational_operator(self): # -> bool:
        ...
    
    def is_arithmetic_operator(self): # -> bool:
        ...
    
    def is_logical_operator(self): # -> bool:
        ...
    
    def is_predicate_operator(self): # -> bool:
        ...
    
    def is_identity_when_one_operand(self): # -> bool:
        ...
    
    def arithmetic_inversion(self): # -> Literal[TypeNode.GT, TypeNode.GE, TypeNode.LE, TypeNode.LT, TypeNode.NE, TypeNode.EQ] | None:
        ...
    
    def logical_inversion(self): # -> Literal[TypeNode.GE, TypeNode.GT, TypeNode.LT, TypeNode.LE, TypeNode.EQ, TypeNode.NE, TypeNode.NOTIN, TypeNode.IN, TypeNode.SUPSEQ, TypeNode.SUPSET, TypeNode.SUBSET, TypeNode.SUBSEQ] | None:
        ...
    
    def is_logically_invertible(self): # -> bool:
        ...
    
    def is_flattenable(self): # -> bool:
        ...
    
    def is_mergeable(self): # -> bool:
        ...
    
    @staticmethod
    def value_of(v): # -> TypeNode | None:
        ...
    


class Node(Entity):
    all_nodes = ...
    def __init__(self, node_type, args) -> None:
        ...
    
    def __bool__(self): # -> Literal[True]:
        ...
    
    def __getitem__(self, i):
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def eq__safe(self, other): # -> bool:
        ...
    
    def __str_hybrid__(self): # -> str:
        ...
    
    def is_leaf(self): # -> bool:
        ...
    
    def is_literal(self): # -> Literal[False]:
        ...
    
    def logical_inversion(self): # -> Node:
        ...
    
    def possible_values(self): # -> range | list[Any] | list[int]:
        ...
    
    def mark_as_used(self): # -> None:
        ...
    
    def abstract_tree(self): # -> str | None:
        ...
    
    def abstract_values(self): # -> None:
        ...
    
    def flatten_by_associativity(self, node_type): # -> None:
        ...
    
    def reduce_integers(self): # -> None:
        ...
    
    def var_val_if_binary_type(self, t): # -> tuple[Any, Any] | None:
        ...
    
    def tree_val_if_binary_type(self, t): # -> tuple[Any, Any] | None:
        ...
    
    def first_node_satisfying(self, predicate): # -> Self | None:
        ...
    
    def all_nodes_satisfying(self, predicate): # -> list[Any]:
        ...
    
    def list_of_ints(self): # -> list[Any]:
        ...
    
    def list_of_vars(self): # -> list[Any]:
        ...
    
    def scope(self): # -> set[Any]:
        ...
    
    def ith_node_satisfying(self, i, predicate): # -> Self | None:
        ...
    
    def var(self, i): # -> list[Node] | Any | None:
        ...
    
    def val(self, i): # -> list[Node] | Any | None:
        ...
    
    def relop(self, i): # -> TypeConditionOperator | None:
        ...
    
    def ariop(self, i): # -> TypeArithmeticOperator | None:
        ...
    
    def logop(self, i): # -> TypeLogicalOperator | None:
        ...
    
    def max_parameter_number(self): # -> list[Node] | Any | int:
        ...
    
    def concretization(self, args): # -> Node:
        ...
    
    def canonization(self, strong=...): # -> Node:
        ...
    
    @staticmethod
    def build(node_type, *args): # -> Node:
        ...
    
    @staticmethod
    def set(*args): # -> Node:
        ...
    
    @staticmethod
    def conjunction(*args):
        ...
    
    @staticmethod
    def disjunction(*args): # -> Node:
        ...
    
    @staticmethod
    def in_range(x, r): # -> Node:
        ...
    
    @staticmethod
    def not_in_range(x, r): # -> Node:
        ...
    
    @staticmethod
    def compare_to(node1, node2): # -> Literal[False, -1, 1, 0]:
        ...
    


class NodeAbstract(Node):
    def __init__(self, abstract_operation: TypeAbstractOperation, args) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


any_node = ...
any_cond = ...
var = ...
val = ...
var_or_val = ...
any_add_val = ...
var_add_val = ...
sub = ...
non = ...
set_vals = ...
min_vars = ...
max_vars = ...
logic_vars = ...
add_vars = ...
mul_vars = ...
add_mul_vals = ...
add_mul_vars = ...
class Matcher:
    def __init__(self, target: Node, p=...) -> None:
        ...
    
    def valid_for_special_target_node(self, node: Node, level: int): # -> Literal[True]:
        ...
    
    def matches(self, tree: Node): # -> bool:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    


x_mul_k = ...
x_mul_y = ...
k_mul_x = ...
abs_sub = ...
abs_neg = ...
not_not = ...
neg_neg = ...
any_lt_k = ...
k_lt_any = ...
not_logop = ...
not_symop_any = ...
any_symop_not = ...
x_mul_k__eq_l = ...
l__eq_x_mul_k = ...
flattenable = ...
mergeable = ...
sub_relop_sub = ...
any_relop_sub = ...
sub_relop_any = ...
any_add_val__relop__any_add_val = ...
var_add_val__relop__val = ...
val__relop__var_add_val = ...
imp_logop = ...
imp_not = ...
canonization_rules_1 = ...
canonization_rules_2 = ...
x_relop_k = ...
k_relop_x = ...
x_ariop_k__relop_l = ...
l_relop__x_ariop_k = ...
x_setop_S = ...
x_in_intvl = ...
x_notin_intvl = ...
x_relop_y = ...
x_ariop_y__relop_k = ...
k_relop__x_ariop_y = ...
x_relop__y_ariop_k = ...
y_ariop_k__relop_x = ...
logic_y_relop_k__eq_x = ...
logic_k_relop_y__eq_x = ...
unalop_x__eq_y = ...
x_ariop_y__relop_z = ...
z_relop__x_ariop_y = ...
logic_y_relop_z__eq_x = ...
logic_X = ...
logic_X__eq_x = ...
logic_X__ne_x = ...
min_relop = ...
max_relop = ...
add_vars__relop = ...
add_mul_vals__relop = ...
add_mul_vars__relop = ...
