"""
This type stub file was generated by pyright.
"""

class Parameter:
    """
    The class used for representing parameters (tokens of the form %i or %...) when handling constraint templates.
    It is used when parsing XCSP3 instances.
    """
    def __init__(self, number) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


class Diffs:
    """
      Objects of this class are used to record the differences between two (or more) close constraints.
      This allows us to build groups in an automatic way.
    """
    fusion = ...
    @staticmethod
    def reset(): # -> None:
        ...
    
    def __init__(self, records=...) -> None:
        ...
    
    def merge(self): # -> None:
        ...
    


class ConstraintArgument:
    def __init__(self, name, content, attributes=..., content_compressible=..., content_ordered=..., lifted=..., adhoc=...) -> None:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __str__(self) -> str:
        ...
    


class Constraint:
    def __init__(self, name) -> None:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def equal_except_condition(self, other): # -> bool:
        ...
    
    def arg(self, name, content, *, attributes=..., content_compressible=..., content_ordered=..., lifted=..., adhoc=...): # -> Self:
        ...
    
    def set_condition(self, operator, right_operand): # -> Self:
        ...
    
    def set_value(self, new_value): # -> Self:
        ...
    
    def similar_structure(self, other): # -> bool:
        ...
    
    def close_to(self, other): # -> Diffs | Literal[False]:
        ...
    
    def parameter_form(self, p): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    


class ConstraintUnmergeable(Constraint):
    def __init__(self, name) -> None:
        ...
    
    def close_to(self, other): # -> Literal[False]:
        ...
    


class ConstraintWithCondition(Constraint):
    def __init__(self, name) -> None:
        ...
    
    def min_possible_value(self): # -> None:
        ...
    
    def max_possible_value(self): # -> None:
        ...
    


class ConstraintIntension(Constraint):
    def __init__(self, tree) -> None:
        ...
    
    def abstract_tree(self):
        ...
    
    def abstract_values(self):
        ...
    
    def close_to(self, other): # -> Diffs | Literal[False]:
        ...
    


class ConstraintExtension(Constraint):
    cache = ...
    cache_for_knowing_if_hybrid = ...
    @staticmethod
    def convert_hybrid_to_ordinary(scope, table): # -> list[Any]:
        ...
    
    @staticmethod
    def remove_redundant_tuples(table):
        ...
    
    def process_table(self, scope, table):
        ...
    
    def __init__(self, scope, table, positive=..., keep_hybrid=..., restrict_table_wrt_domains=...) -> None:
        ...
    
    def close_to(self, other): # -> Diffs | Literal[False]:
        ...
    


class ConstraintRegular(Constraint):
    def __init__(self, lst, automaton) -> None:
        ...
    
    def close_to(self, other): # -> Diffs | Literal[False]:
        ...
    


class ConstraintMdd(Constraint):
    def __init__(self, lst, mdd) -> None:
        ...
    


class ConstraintAllDifferent(Constraint):
    def __init__(self, lst, excepting) -> None:
        ...
    


class ConstraintAllDifferentList(ConstraintUnmergeable):
    def __init__(self, lst, excepting) -> None:
        ...
    


class ConstraintAllDifferentMatrix(ConstraintUnmergeable):
    def __init__(self, lst, excepting) -> None:
        ...
    


class ConstraintAllEqual(Constraint):
    def __init__(self, lst, excepting) -> None:
        ...
    


class ConstraintAllEqualList(ConstraintUnmergeable):
    def __init__(self, lst, excepting) -> None:
        ...
    


class ConstraintOrdered(Constraint):
    def __init__(self, lst, operator, lengths) -> None:
        ...
    
    def to_list(self): # -> list[Any]:
        ...
    
    def to_intension(self): # -> ConstraintDummyConstant:
        ...
    


class ConstraintLex(ConstraintUnmergeable):
    def __init__(self, lst, operator) -> None:
        ...
    


class ConstraintLexMatrix(ConstraintUnmergeable):
    def __init__(self, lst, operator) -> None:
        ...
    


class ConstraintPrecedence(Constraint):
    def __init__(self, lst, *, values=..., covered=...) -> None:
        ...
    


class ConstraintSum(ConstraintWithCondition):
    def __init__(self, lst, coefficients, condition) -> None:
        ...
    
    def min_possible_value(self): # -> int:
        ...
    
    def max_possible_value(self): # -> int:
        ...
    
    def revert_coeffs(self): # -> Self:
        ...
    
    def add(self, term): # -> Self:
        ...
    


class ConstraintCount(ConstraintWithCondition):
    def __init__(self, lst, values, condition) -> None:
        ...
    
    def min_possible_value(self): # -> Literal[0]:
        ...
    
    def max_possible_value(self): # -> int:
        ...
    


class ConstraintNValues(ConstraintWithCondition):
    def __init__(self, lst, excepting, condition) -> None:
        ...
    
    def min_possible_value(self): # -> Literal[1]:
        ...
    
    def max_possible_value(self): # -> int:
        ...
    


class ConstraintCardinality(Constraint):
    def __init__(self, lst, values, occurs, closed=...) -> None:
        ...
    


class ConstraintMaximum(ConstraintWithCondition):
    def __init__(self, lst, condition=...) -> None:
        ...
    
    def min_possible_value(self):
        ...
    
    def max_possible_value(self):
        ...
    
    def all_possible_values(self): # -> set[Any]:
        ...
    


class ConstraintMinimum(ConstraintWithCondition):
    def __init__(self, lst, condition=...) -> None:
        ...
    
    def min_possible_value(self):
        ...
    
    def max_possible_value(self):
        ...
    
    def all_possible_values(self): # -> set[Any]:
        ...
    


class ConstraintMaximumArg(ConstraintWithCondition):
    def __init__(self, lst, type_rank=..., condition=...) -> None:
        ...
    
    def min_possible_value(self): # -> Literal[0]:
        ...
    
    def max_possible_value(self): # -> int:
        ...
    


class ConstraintMinimumArg(ConstraintWithCondition):
    def __init__(self, lst, type_rank=..., condition=...) -> None:
        ...
    
    def min_possible_value(self): # -> Literal[0]:
        ...
    
    def max_possible_value(self): # -> int:
        ...
    


class ConstraintElement(ConstraintWithCondition):
    def __init__(self, lst, *, index, type_rank=..., condition=...) -> None:
        ...
    
    def min_possible_value(self):
        ...
    
    def max_possible_value(self):
        ...
    


class ConstraintElementMatrix(ConstraintWithCondition):
    def __init__(self, lst, index1, index2, value=..., start_row_index=..., start_col_index=...) -> None:
        ...
    
    def min_possible_value(self):
        ...
    
    def max_possible_value(self):
        ...
    


class ConstraintChannel(ConstraintUnmergeable):
    def __init__(self, list1, start_index1, list2, start_index2) -> None:
        ...
    


class ConstraintNoOverlap(ConstraintUnmergeable):
    def __init__(self, origins, lengths, zero_ignored) -> None:
        ...
    


class ConstraintCumulative(Constraint):
    def __init__(self, origins, lengths, ends, heights, condition) -> None:
        ...
    


class ConstraintBinPacking(ConstraintUnmergeable):
    def __init__(self, lst, sizes, *, limits=..., loads=..., condition=...) -> None:
        ...
    


class ConstraintKnapsack(ConstraintWithCondition):
    def __init__(self, lst, weights, wcondition, profits, pcondition) -> None:
        ...
    
    def min_possible_value(self): # -> int:
        ...
    
    def max_possible_value(self): # -> int:
        ...
    
    def close_to(self, other): # -> Literal[False]:
        ...
    


class ConstraintFlow(Constraint):
    def __init__(self, lst, balance, arcs, weights, condition) -> None:
        ...
    


class ConstraintCircuit(Constraint):
    def __init__(self, variables, start_index, size) -> None:
        ...
    


class ConstraintClause(Constraint):
    def __init__(self, variables, phases) -> None:
        ...
    


class ConstraintAdhoc(ConstraintUnmergeable):
    def __init__(self, form, note, d) -> None:
        ...
    


class ConstraintInstantiationRefutation(Constraint):
    def __init__(self, variables, values, name) -> None:
        ...
    
    def to_list(self): # -> list[Any]:
        ...
    
    def to_intension(self): # -> ConstraintDummyConstant:
        ...
    


class ConstraintInstantiation(ConstraintInstantiationRefutation):
    def __init__(self, variables, values) -> None:
        ...
    


class ConstraintRefutation(ConstraintInstantiationRefutation):
    def __init__(self, variables, values) -> None:
        ...
    


class ConstraintSlide(ConstraintUnmergeable):
    def __init__(self, variables, slide_expression, circular=..., offset=..., collect=...) -> None:
        ...
    


class ConstraintDummyConstant(ConstraintUnmergeable):
    def __init__(self, val) -> None:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __le__(self, other) -> bool:
        ...
    
    def __ge__(self, other) -> bool:
        ...
    
    def __gt__(self, other) -> bool:
        ...
    


class PartialConstraint:
    def __init__(self, constraint) -> None:
        ...
    
    def add_condition(self, operator, right_operand): # -> ECtr:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __le__(self, other) -> bool:
        ...
    
    def __ge__(self, other) -> bool:
        ...
    
    def __gt__(self, other) -> bool:
        ...
    
    def __add__(self, other): # -> Self | Node | PartialConstraint | Any:
        ...
    
    def __sub__(self, other): # -> Self | Node | PartialConstraint | Any:
        ...
    
    def __mul__(self, other): # -> Node | PartialConstraint | Any | Self:
        ...
    
    def __rmul__(self, other): # -> Node | PartialConstraint | Any:
        ...
    
    def __floordiv__(self, other): # -> Node:
        ...
    
    def __mod__(self, other): # -> Node:
        ...
    
    def __getitem__(self, i): # -> Self:
        ...
    
    def __contains__(self, item): # -> bool:
        ...
    
    def __str__(self) -> str:
        ...
    
    @staticmethod
    def combine_partial_objects(obj1, operator, obj2): # -> PartialConstraint | Any:
        ...
    


class ScalarProduct:
    def __init__(self, variables, coefficients) -> None:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __le__(self, other) -> bool:
        ...
    
    def __ge__(self, other) -> bool:
        ...
    
    def __gt__(self, other) -> bool:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __add__(self, other): # -> PartialConstraint | Any:
        ...
    
    def __sub__(self, other): # -> PartialConstraint | Any:
        ...
    
    def __floordiv__(self, other): # -> Node:
        ...
    
    def __mod__(self, other): # -> Node:
        ...
    
    def __mul__(self, other): # -> Node:
        ...
    
    def to_terms(self): # -> list[Any]:
        ...
    


class _Auxiliary:
    cache_ints = ...
    cache_nodes = ...
    def __init__(self) -> None:
        ...
    
    def new_var(self, *args): # -> VariableInteger:
        ...
    
    def n_introduced_variables(self): # -> int:
        ...
    
    def replace_partial_constraint(self, pc): # -> VariableInteger:
        ...
    
    def replace_constraint_with_condition(self, cc): # -> Node:
        ...
    
    def replace_node(self, node, *, values=...): # -> VariableInteger:
        ...
    
    def replace_partial_constraint_and_constraint_with_condition_and_possibly_node(self, term, *, node_too=..., values=...): # -> VariableInteger | Node:
        ...
    
    def replace_partial_constraints_and_constraints_with_condition_and_possibly_nodes(self, terms, *, nodes_too=..., values=...): # -> list[Any]:
        ...
    
    def replace_element_index(self, length, index): # -> VariableInteger | None:
        ...
    
    def replace_int(self, v): # -> VariableInteger:
        ...
    
    def replace_ints(self, lst): # -> ListInt | ListVar | ListCtr | ListMix | list[Any]:
        ...
    
    def normalize_list(self, lst): # -> ListVar:
        ...
    
    def collect_table(self, index, aux, table): # -> None:
        ...
    
    def get_collected_and_clear(self): # -> list[Any]:
        ...
    
    def get_collected_raw_and_clear(self): # -> list[Any]:
        ...
    
    def get_collected_extension_and_clear(self): # -> list[Any]:
        ...
    


def auxiliary(): # -> _Auxiliary | Any:
    ...

def global_indirection(c): # -> ConstraintDummyConstant | Node | None:
    ...

def manage_global_indirection(*args, also_pc=...): # -> list[Any] | None:
    ...

