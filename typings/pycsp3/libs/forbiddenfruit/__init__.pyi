"""
This type stub file was generated by pyright.
"""

import sys
import ctypes
import inspect
import builtins as __builtin__
from types import FunctionType
from functools import wraps
from collections import defaultdict

__version__ = ...
__all__ = ('curse', 'curses', 'reverse')
Py_ssize_t = ...
tp_as_dict = ...
tp_func_dict = ...
class PyObject(ctypes.Structure):
    def incref(self): # -> None:
        ...
    
    def decref(self): # -> None:
        ...
    


class PyFile(ctypes.Structure):
    ...


PyObject_p = ctypes.py_object
Inquiry_p = ...
UnaryFunc_p = ...
BinaryFunc_p = ...
TernaryFunc_p = ...
LenFunc_p = ...
SSizeArgFunc_p = ...
SSizeObjArgProc_p = ...
ObjObjProc_p = ...
FILE_p = ...
def get_not_implemented():
    ...

NotImplementedRet = ...
class PyNumberMethods(ctypes.Structure):
    _fields_ = ...


class PySequenceMethods(ctypes.Structure):
    _fields_ = ...


class PyMappingMethods(ctypes.Structure):
    ...


class PyTypeObject(ctypes.Structure):
    ...


class PyAsyncMethods(ctypes.Structure):
    ...


PyTypeObject_as_types_dict = ...
class SlotsProxy(PyObject):
    _fields_ = ...


def patchable_builtin(klass):
    ...

@wraps(__builtin__.dir)
def __filtered_dir__(obj=...): # -> list[str]:
    ...

__hidden_elements__ = ...
__dir__ = ...
as_number = ...
as_sequence = ...
as_async = ...
override_dict = ...
def curse(klass, attr, value, hide_from_dir=...): # -> None:
    """Curse a built-in `klass` with `attr` set to `value`

    This function monkey-patches the built-in python object `attr` adding a new
    attribute to it. You can add any kind of argument to the `class`.

    It's possible to attach methods as class methods, just do the following:

      >>> def myclassmethod(cls):
      ...     return cls(1.5)
      >>> curse(float, "myclassmethod", classmethod(myclassmethod))
      >>> float.myclassmethod()
      1.5

    Methods will be automatically bound, so don't forget to add a self
    parameter to them, like this:

      >>> def hello(self):
      ...     return self * 2
      >>> curse(str, "hello", hello)
      >>> "yo".hello()
      "yoyo"
    """
    ...

def reverse(klass, attr): # -> None:
    """Reverse a curse in a built-in object

    This function removes *new* attributes. It's actually possible to remove
    any kind of attribute from any built-in class, but just DON'T DO IT :)

    Good:

      >>> curse(str, "blah", "bleh")
      >>> assert "blah" in dir(str)
      >>> reverse(str, "blah")
      >>> assert "blah" not in dir(str)

    Bad:

      >>> reverse(str, "strip")
      >>> " blah ".strip()
      Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
      AttributeError: 'str' object has no attribute 'strip'

    """
    ...

def curses(klass, name): # -> Callable[..., Any]:
    """Decorator to add decorated method named `name` the class `klass`

    So you can use it like this:

        >>> @curses(dict, 'banner')
        ... def dict_banner(self):
        ...     l = len(self)
        ...     print('This dict has {0} element{1}'.format(
        ...         l, l is 1 and '' or 's')
        >>> {'a': 1, 'b': 2}.banner()
        'This dict has 2 elements'
    """
    ...

