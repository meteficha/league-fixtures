"""
This type stub file was generated by pyright.
"""

started_modeling = ...
def protect(): # -> type[OpOverrider]:
    """
    Disables the redefined operators (==, >, >=, etc.), and returns the object OpOverrider.
    On can then execute some code in protected mode by calling execute().
    Once the code is executed, the redefined operators are reactivated.

    The code typically looks like:
      protect().execute(...)

    :return: the object OpOverrider
    """
    ...

def variant(name=...): # -> str:
    """
    Returns the name of the variant given on the command line (option -variant) if the specified argument is None.
    Returns True iff the variant given on the command line is equal to the argument otherwise.
    Note that the variant given on the command line is the substring until the symbol '-' (after this symbol,
    the name of the sub-variant starts), or the end of the string

    :param name: the name of a variant, or None
    :return: the name of the variant specified by the user, or a Boolean
    """
    ...

def subvariant(name=...): # -> str | None:
    """
    Returns the name of the sub-variant given on the command line (option -variant) if the specified argument is None.
    Returns True iff the sub-variant given on the command line is equal to the argument otherwise.
    Note that the sub-variant given on the command line is the substring starting after the symbol '-' (before this symbol,
    this is the name of the variant).

    :param name: the name of a sub-variant, or None
    :return: the name of the sub-variant specified by the user, or a Boolean
    """
    ...

def Var(term=..., *others, dom=..., id=...): # -> VariableInteger | VariableSymbolic:
    """
    Builds a stand-alone variable with the specified domain.
    The domain is either given by the named parameter dom, or given
    by the sequence of terms passed as parameters. For example:
      x = Var(0,1)
      y = Var(range(10))
      z = Var(v for v in range(100) if v%3 == 0)

    :param term: the first term defining the domain, or None
    :param others: the other terms defining the domain, or None
    :param dom: the domain of the variable, or None
    :param id: the id (name) of the variable, or None (usually, None)
    :return: a stand-alone Variable with the specified domain
    """
    ...

def VarArray(doms=..., *, size=..., dom=..., dom_border=..., id=..., comment=...): # -> tuple[Any, ...] | Variable | ListVar | None:
    """
    Builds an array of variables.
    The number of dimensions of the array is given by the number of values in size.
    The size of the ith dimension is given by the ith value of size.
    The domain is either the same for all variables, and then directly given by dom,
    or specific to each variable, in which case dom must a function.

    :param size: the size of each dimension of the array
    :param dom: the domain of the variables
    :param dom_border: the domain of the cells at the border of the (two-dimensional) array
    :param id: the id (name) of the array, or None (usually, None)
    :param comment: a string
    :return: an array of variables
    """
    ...

def var(name):
    """
    Returns the variable or variable array whose name is specified
    :param name: the name of the variable or variable array to be returned
    """
    ...

def And(*args, meta=...): # -> EAnd | ConstraintDummyConstant:
    """
    Builds a meta-constraint And from the specified arguments.
    For example: And(Sum(x) > 10, AllDifferent(x))

    When the parameter 'meta' is not true,
    reification is employed.

    :param args: a tuple of constraints
    :param meta true if a meta-constraint form must be really posted
    :return: a meta-constraint And, or its reified form
    """
    ...

def Or(*args, meta=...): # -> EOr | ConstraintDummyConstant | Node:
    """
    Builds a meta-constraint Or from the specified arguments.
    For example: Or(Sum(x) > 10, AllDifferent(x))

    When the parameter 'meta' is not true,
    reification is employed.

    :param args: a tuple of constraints
    :param meta true if a meta-constraint form must be really posted
    :return: a meta-constraint Or, or its reified form
    """
    ...

def Not(arg, meta=...): # -> ENot:
    """
    Builds a meta-constraint Not from the specified argument.
    For example: Not(AllDifferent(x))

    When the parameter 'meta' is not true,
    reification is employed.

    :param arg: a constraint
    :param meta true if a meta-constraint form must be really posted
    :return: a meta-constraint Not, or its reified form
    """
    ...

def Xor(*args, meta=...): # -> EXor | Node | ConstraintDummyConstant:
    """
    Builds a meta-constraint Xor from the specified arguments.
    For example: Xor(Sum(x) > 10, AllDifferent(x))

    When the parameter 'meta' is not true,
    reification is employed.

    :param args: a tuple of constraints
    :param meta true if a meta-constraint form must be really posted
    :return: a meta-constraint Xor, or its reified form
    """
    ...

def If(test, *test_complement, Then, Else=..., meta=...): # -> EOr | ConstraintDummyConstant | Node | EIfThen | EIfThenElse | list[Any | list[Any | list[Any] | EOr | ConstraintDummyConstant | Node | EIfThen | EIfThenElse | None] | EOr | ConstraintDummyConstant | Node | EIfThen | EIfThenElse | list[Any] | None] | list[Any] | None:
    """
    Builds a complex form of constraint(s), based on the general control structure 'if then else'
    that can possibly be decomposed, at compilation time.

    For example:
      - If(Sum(x) > 10, Then=AllDifferent(x))
      - If(Sum(x) > 10, Then=AllDifferent(x), Else=AllEqual(x))
      - If(w > 0, y != z, Then=w == y + z)
      - If(w > 0, y != z, Then=[w == y + z, v != 1])
      - If(Sum(x) > 10, Then=y == z, Else=[AllEqual(x), y < 3])

    When the parameter 'meta' is not true (the usual and default case),
    reification may be employed.

    :param test: the condition expression
    :param test_complement: the other terms (if any) of the condition expression (assuming a conjunction)
    :param Then the Then part
    :param Else the Else part
    :param meta true if a meta-constraint form must be really posted
    :return: a complex form of constraint(s) based on the control structure 'if then else'
    """
    ...

def Match(Expr, *, Cases): # -> list[ConstraintDummyConstant | Any | Node] | list[Any]:
    ...

def Iff(*args, meta=...): # -> EIff | bool | ConstraintDummyConstant | Node:
    """
    Builds a meta-constraint Iff from the specified arguments.
    For example: Iff(Sum(x) > 10, AllDifferent(x))

    When the parameter 'meta' is not true,
    reification is employed.

    :param args: a tuple of constraints
    :param meta true if a meta-constraint form must be really posted
    :return: a meta-constraint Iff, or its reified form
    """
    ...

def Slide(*args, expression=..., circular=..., offset=..., collect=...): # -> ECtr | ESlide:
    """
    Builds a meta-constraint Slide from the specified arguments.
    Slide((x[i], x[i + 1]) in table for i in range(n - 1))

    According to the specified constraints, the compiler may or may not succeed
    in generating a slide meta-constraint.

    :param args: a tuple of constraints
    :return: a meta-constraint Slide
    """
    ...

def satisfy_from_auxiliary(t): # -> EToSatisfy:
    ...

def satisfy(*args, no_comment_tags_extraction=...):
    """
    Posts all constraints that are specified as arguments

    :param args: the different constraints to be posted
    :return: an object wrapping the posted constraints
    """
    ...

def Table(*, scope, supports=..., conflicts=...): # -> ECtr:
    """
    Builds and returns a constraint Table.

    :param scope: the sequence of (distinct) involved variables
    :param supports: the set/list of tuples, seen as supports (positive table)
    :param conflicts: the set/list of tuples, seen as conflicts (negative table)

    :return: a constraint Table (Extension)
    """
    ...

def col(*args): # -> Node:
    ...

def abs(arg): # -> Node | Any:
    """
    If the specified argument is a node or a variable of the model, the function builds
    and returns a node 'abs', root of a tree expression where the specified argument is a child.
    Otherwise, the function returns, as usual, the absolute value of the specified argument

    :return: either a node, root of a tree expression, or the absolute value of the specified argument
    """
    ...

def min(*args): # -> int | str | Node:
    """
    When one of the specified arguments is a node or a variable of the model, the function builds
    and returns a node 'min', root of a tree expression where specified arguments are children.
    Otherwise, the function returns, as usual, the smallest item of the specified arguments

    :return: either a node, root of a tree expression, or the smallest item of the specified arguments
    """
    ...

def max(*args): # -> int | str | Node:
    """
    When one of the specified arguments is a node or a variable of the model, the function builds
    and returns a node 'max', root of a tree expression where specified arguments are children.
    Otherwise, the function returns, as usual, the largest item of the specified arguments

    :return: either a node, root of a tree expression, or the largest item of the specified arguments
    """
    ...

def xor(*args): # -> Node | ConstraintDummyConstant:
    """
    If there is only one argument, returns it.
    Otherwise, builds and returns a node 'xor', root of a tree expression where specified arguments are children.
    Without any parent, it becomes a constraint.

    :return: a node, root of a tree expression or the argument if there is only one
    """
    ...

def iff(*args): # -> EIff | bool | ConstraintDummyConstant | Node:
    """
    Builds and returns a node 'iff', root of a tree expression where specified arguments are children.
    Without any parent, it becomes a constraint.

    :return: a node, root of a tree expression
    """
    ...

def imply(*args): # -> list[Any | list[Any] | EOr | ConstraintDummyConstant | Node | EIfThen | EIfThenElse | None] | EOr | ConstraintDummyConstant | Node | EIfThen | EIfThenElse | list[Any] | None:
    """
    Builds and returns a node 'imply', root of a tree expression where specified arguments are children.
    Without any parent, it becomes a constraint.

    :param args: a tuple of two arguments
    :return: a node, root of a tree expression
    """
    ...

def ift(test, Then, Else): # -> list[Any | list[Any] | EOr | ConstraintDummyConstant | Node | EIfThen | EIfThenElse | None] | EOr | ConstraintDummyConstant | Node | EIfThen | EIfThenElse | list[Any] | list[Any | list[Any | list[Any] | EOr | ConstraintDummyConstant | Node | EIfThen | EIfThenElse | None] | EOr | ConstraintDummyConstant | Node | EIfThen | EIfThenElse | list[Any] | None] | None:
    """
    Builds and returns a node 'ifthenelse', root of a tree expression where specified arguments are children.
    Without any parent, it becomes a constraint.

    :param test: the condition expression
    :param Then the Then part
    :param Else the Else part

    :return: a node, root of a tree expression
    """
    ...

def belong(x, values): # -> ConstraintDummyConstant | Node:
    ...

def not_belong(x, values): # -> ConstraintDummyConstant | Node:
    ...

def expr(operator, *args): # -> Node:
    """
    Builds and returns a node, root of a tree expression where specified arguments are children.
    The type of the new node is given by the specified operator.
    When it is a string, it can be among {"<", "lt", "<=", "le", ">=", "ge", ">", "gt", "=", "==", "eq", "!=", "<>", "ne"}
    Without any parent, it becomes a constraint.

    :param operator: a string, or a constant from TypeNode or a constant from TypeConditionOperator or TypeOrderedOperator
    :return: a node, root of a tree expression
    """
    ...

def conjunction(*args): # -> ConstraintDummyConstant:
    """
    Builds and returns a node 'and', root of a tree expression where specified arguments are children.
    Without any parent, it becomes a constraint.

    :return: a node, root of a tree expression
    """
    ...

def both(this, And): # -> ConstraintDummyConstant:
    """
    Builds and returns a node 'and', root of a tree expression where the two specified arguments are children.
    Without any parent, it becomes a constraint.

    :return: a node, root of a tree expression
    """
    ...

def disjunction(*args): # -> ConstraintDummyConstant | Node:
    """
    Builds and returns a node 'or', root of a tree expression where specified arguments are children.
    Without any parent, it becomes a constraint.

    :return: a node, root of a tree expression
    """
    ...

def either(this, Or): # -> ConstraintDummyConstant | Node:
    """
    Builds and returns a node 'or', root of a tree expression where the two specified arguments are children.
    Without any parent, it becomes a constraint.

    :return: a node, root of a tree expression
    """
    ...

def Regular(*, scope, automaton): # -> ECtr:
    """
    Builds and returns a constraint Regular.

    :param scope: the sequence of (distinct) involved variables
    :param automaton: the automaton defining the semantics of the constraint

    :return: a constraint Regular
    """
    ...

def Mdd(*, scope, mdd): # -> ECtr:
    """
    Builds and returns a constraint MDD.

    :param scope: the sequence of (distinct) involved variables
    :param mdd: the multi-decision diagram defining the semantics of the constraint

    :return: a constraint MDD
    """
    ...

def AllDifferent(term, *others, excepting=..., matrix=...): # -> ECtr | list[ECtr | list[Any] | None] | None:
    """
    Builds and returns a constraint AllDifferent.

    :param term: the (first) term, typically a list of variables, on which the constraint applies
    :param others: the other terms (if any) on which the constraint applies
    :param excepting: the value(s) that must be ignored (None, most of the time)
    :param matrix: if True, the matrix version must be considered
    :return: a constraint AllDifferent
    """
    ...

def AllDifferentList(term, *others, excepting=...): # -> ECtr:
    """
    Builds and returns a constraint AllDifferentList.

    :param term: the (first) term, typically a list of lists of variables, on which the constraint applies
    :param others: the other terms (if any) on which the constraint applies
    :param excepting: the tuple(s) that must be ignored (None, most of the time)
    :return: a constraint AllDifferentList
    """
    ...

def AllEqual(term, *others, excepting=...): # -> ECtr:
    """
    Builds and returns a constraint AllEqual.

    :param term: the (first) term, typically a list of variables or expressions, on which the constraint applies
    :param others: the other terms (if any) on which the constraint applies
    :param excepting: the value(s) that must be ignored (None, most of the time)
    :return: a constraint AllEqual
    """
    ...

def AllEqualList(term, *others, excepting=...): # -> list[Any] | ECtr:
    """
    Builds and returns a constraint AllEqualList. In case only two lists are given, and excepting is None,
    a group of intensional constraints of the form x[i] == y[i] is posted

    :param term: the (first) term, typically a list of lists of variables, on which the constraint applies
    :param others: the other terms (if any) on which the constraint applies
    :param excepting: the tuple(s) that must be ignored (None, most of the time)
    :return: a constraint AllEqualList
    """
    ...

def Increasing(term, *others, strict=..., lengths=...): # -> list[Node] | ECtr | None:
    """
    Builds and returns a constraint Increasing.

    :param term: the (first) term, typically a list of variables, on which the constraint applies
    :param others: the other terms (if any) on which the constraint applies
    :param strict: if True, strict ordering must be considered
    :param lengths: the lengths (durations) that must separate the values
    :return: a constraint Increasing
    """
    ...

def Decreasing(term, *others, strict=..., lengths=...): # -> list[Node] | ECtr | None:
    """
    Builds and returns a constraint Decreasing.

    :param term: the (first) term, typically a list of variables, on which the constraint applies
    :param others: the other terms (if any) on which the constraint applies
    :param strict: if True, strict ordering must be considered
    :param lengths: the lengths (durations) that must separate the values
    :return: a constraint Decreasing
    """
    ...

def LexIncreasing(term, *others, strict=..., matrix=...): # -> ECtr:
    """
    Builds and returns a constraint (increasing) Lexicographic.

    :param term: the (first) term, typically a list of lists of variables, on which the constraint applies
    :param others: the other terms (if any) on which the constraint applies
    :param strict: if True, strict ordering must be considered
    :param matrix: if True, the matrix version must be considered
    :return: a constraint Lexicographic
    """
    ...

def LexDecreasing(term, *others, strict=..., matrix=...): # -> ECtr:
    """
    Builds and returns a constraint (decreasing) Lexicographic.

    :param term: the (first) term, typically a list of lists of variables, on which the constraint applies
    :param others: the other terms (if any) on which the constraint applies
    :param strict: if True, strict ordering must be considered
    :param matrix: if True, the matrix version must be considered
    :return: a constraint Lexicographic
    """
    ...

def Precedence(within, *, values=..., covered=...): # -> ECtr | None:
    """
    Builds and returns a constraint Precedence.

    :param within: the scope of the constraint
    :param values: the values such that the ith value must precede the i+1th value in the scope.
    when None, all values in the scope of the first variable are considered
    :param covered: if True, all specified values must be assigned to the variables of the scope
    :return: a constraint Precedence
    """
    ...

def Sum(term, *others, condition=...): # -> Any | ECtr | PartialConstraint | Literal[0]:
    """
    Builds and returns a component Sum (that becomes a constraint when subject to a condition)

    :param term: the first term on which the sum applies
    :param others: the other terms (if any) on which the sum applies
    :param condition: a condition directly specified for the sum (typically, None)
    :return: a component/constraint Sum
    """
    ...

def Product(term, *others): # -> Node:
    """
    Builds and returns a node 'mul', root of a tree expression where specified arguments are children

    :param term: the first term on which the product applies
    :param others: the other terms (if any) on which the product applies
    :return: a node, root of a tree expression
    """
    ...

def Count(within, *within_complement, value=..., values=..., condition=...): # -> ConstraintDummyConstant | ECtr | PartialConstraint:
    """
    Builds and returns a component Count (that becomes a constraint when subject to a condition).
    Either the named parameter value or the named parameter values must be used.

    :param within: the (first) term, typically a list of variables or expressions, on which the count applies
    :param within_complement: the other terms (if any) on which the count applies
    :param value: the value to be counted
    :param values: the values to be counted
    :param condition: a condition directly specified for the count (typically, None)
    :return: a component/constraint Count
    """
    ...

def Exist(within, *within_complement, value=...): # -> ConstraintDummyConstant | Node | ECtr | Literal[0]:
    """
    Builds and returns a constraint Count that checks if at least one of the term evaluates to the specified value,
    or to 1 (seen as True) when value is None.

    :param within: the (first) term, typically  a list of variables or expressions, on which the count applies
    :param within_complement: the other terms (if any) on which the count applies
    :param value the value to be found if not None (None, by default)
    :return: a constraint Count
    """
    ...

def AnyHold(within, *within_complement): # -> ConstraintDummyConstant | Node | ECtr | Literal[0]:
    """
    Builds and returns a constraint Count that checks if at least one term evaluates to 1 (seen as True).

    :param within: the first term on which the count applies
    :param within_complement: the other terms (if any) on which the count applies
    :return: a constraint Count
    """
    ...

def NotExist(within, *within_complement, value=...): # -> bool | ConstraintDummyConstant | list[Any] | ECtr | Literal[1]:
    """
    Builds and returns a constraint Count that checks that no term evaluates to the specified value,
    or to 1 (seen as True) when value is None.

    :param within: the (first) term, typically a list of variables or expressions, on which the count applies
    :param within_complement: the other terms (if any) on which the count applies
    :param value the value to be tested if not None (None, by default)
    :return: a constraint Count
    """
    ...

def NoneHold(within, *within_complement): # -> bool | ConstraintDummyConstant | list[Any] | ECtr | Literal[1]:
    """
    Builds and returns a constraint Count that checks that no term evaluates to 1 (seen as True).

    :param within: the first term on which the count applies
    :param within_complement: the other terms (if any) on which the count applies
    :return: a constraint Count
    """
    ...

def ExactlyOne(within, *within_complement, value=...): # -> bool | ConstraintDummyConstant | list[Any] | ECtr | Literal[0]:
    """
    Builds and returns a constraint Count that checks that exactly one term evaluates to 1 (seen as True) when value is not specified,
    or to the value (when the parameter is specified, and not None)

    :param within: the first term on which the count applies
    :param within_complement: the other terms (if any) on which the count applies
    :param value the value to be found if not None (None, by default)
    :return: a constraint Count
    """
    ...

def AtLeastOne(within, *within_complement, value=...): # -> ConstraintDummyConstant | Node | ECtr | Literal[0]:
    """
    Builds and returns a constraint Count that checks that at least one term evaluates to 1 (seen as True) when value is not specified,
    or to the value (when the parameter is specified, and not None).

    :param within: the first term on which the count applies
    :param within_complement: the other terms (if any) on which the count applies
    :param value the value to be found if not None (None, by default)
    :return: a constraint Count
    """
    ...

def AtMostOne(within, *within_complement, value=...): # -> ConstraintDummyConstant | ECtr | Literal[1]:
    """
    Builds and returns a constraint Count that checks that at most one term evaluates to 1 (seen as True) when value is not specified,
    or to the value (when the parameter is specified, and not None).

    :param within: the first term on which the count applies
    :param within_complement: the other terms (if any) on which the count applies
    :param value the value to be found if not None (None, by default)
    :return: a constraint Count
    """
    ...

def AllHold(within, *within_complement): # -> bool | ConstraintDummyConstant | list[Any] | ECtr | Literal[1]:
    """
    Builds and returns a constraint Count that checks that all terms evaluate to 1 (seen as True).

    :param within: the first term on which the count applies
    :param within_complement: the other terms (if any) on which the count applies
    :return: a constraint Count
    """
    ...

def Hamming(term, *others): # -> Any | ECtr | PartialConstraint | Literal[0]:
    """
    Builds and returns a constraint Sum, corresponding to the Hamming distance of the two specified lists.

    :param term: the first term on which the constraint applies
    :param others: the other terms (if any) on which the constraint applies
    :return: a constraint Sum
    """
    ...

def NValues(within, *within_complement, excepting=..., condition=...): # -> ECtr | PartialConstraint | Literal[0]:
    """
    Builds and returns a component NValues (that becomes a constraint when subject to a condition).

    :param within: the (first) term, typically a list of variables, on which the NValues applies
    :param within_complement: the other terms (if any) on which the NValues applies
    :param excepting: the value(s) that must be ignored (None, most of the time)
    :param condition: a condition directly specified for the count (typically, None)
    :return: a component/constraint NValues
    """
    ...

def NumberDistinctValues(within, *within_complement, excepting=..., condition=...): # -> ECtr | PartialConstraint | Literal[0]:
    """
        Builds and returns a component NValues (that becomes a constraint when subject to a condition).
        This function is an alias for the function 'NValues()'

        :param within: the (first) term, typically a list of variables, on which the NValues applies
        :param within_complement: the other terms (if any) on which the NValues applies
        :param excepting: the value(s) that must be ignored (None, most of the time)
        :param condition: a condition directly specified for the count (typically, None)
        :return: a component/constraint NValues
        """
    ...

def NotAllEqual(term, *others): # -> ECtr | bool:
    """
      Builds and returns a component NValues (capturing NotAllEqual)

      :param term: the first term on which the constraint applies
      :param others: the other terms (if any) on which the constraint applies
      :return: a constraint NValues (equivalent to NotAllEqual)
      """
    ...

def Cardinality(within, *within_complement, occurrences, closed=...): # -> ECtr:
    """
    Builds and returns a constraint Cardinality.

    When occurrences is given under the form of a list or tuple t,
    a dictionary is computed as dict(enumerate(t))

    :param within: the (first) term, typically a list of variables, on which the constraint applies
    :param within_complement: the other terms (if any) on which the constraint applies
    :param occurrences: a dictionary indicating the restriction (constant, range or variable) of occurrences per value
    :param closed: if True, variables must be assigned to values (keys of the dictionary)
    :return: a Cardinality constraint
    """
    ...

def Maximum(term, *others, condition=...): # -> Any | ECtr | PartialConstraint | int:
    """
    Builds and returns a component Maximum (that becomes a constraint when subject to a condition).

    :param term: the first term on which the maximum applies
    :param others: the other terms (if any) on which the maximum applies
    :param condition: a condition directly specified for the maximum (typically, None)
    :return: a component/constraint Maximum
    """
    ...

def Minimum(term, *others, condition=...): # -> Any | ECtr | PartialConstraint | int:
    """
    Builds and returns a component Minimum (that becomes a constraint when subject to a condition).

    :param term: the first term on which the minimum applies
    :param others: the other terms (if any) on which the minimum applies
    :param condition: a condition directly specified for the minimum (typically, None)
    :return: a component/constraint Minimum
    """
    ...

def MaximumArg(term, *others, rank=..., condition=...): # -> ECtr | PartialConstraint:
    """
    Builds and returns a component MaximumArg (that becomes a constraint when subject to a condition).

    :param term: the first term on which the maximum applies
    :param others: the other terms (if any) on which the maximum applies
    :param rank: ranking condition on the index (ANY, FIRST or LAST); ANY if None
    :param condition: a condition directly specified for the maximum (typically, None)
    :return: a component/constraint MaximumArg
    """
    ...

def MinimumArg(term, *others, rank=..., condition=...): # -> ECtr | PartialConstraint:
    """
    Builds and returns a component MinimumArg (that becomes a constraint when subject to a condition).

    :param term: the first term on which the maximum applies
    :param others: the other terms (if any) on which the maximum applies
    :param rank: ranking condition on the index (ANY, FIRST or LAST); ANY if None
    :param condition: a condition directly specified for the maximum (typically, None)
    :return: a component/constraint MinimumArg
    """
    ...

def Channel(list1, list2=..., *, start_index1=..., start_index2=...): # -> list[Any] | ECtr:
    """
    Builds a constraint Channel between the two specified lists.

    :param list1: the first list to be channeled
    :param list2: the second list to be channeled
    :param start_index1: the number used for indexing the first variable in the first list (0, by default)
    :param start_index2: the number used for indexing the first variable in the second list (0, by default)
    :return: a constraint Channel
    """
    ...

def NoOverlap(tasks=..., *, origins=..., lengths=..., zero_ignored=...):
    """
    Builds and returns a constraint NoOverlap.
    Either the tasks are specified as pairs, or the tasks are given by the name parameters origins and lengths.

    :param tasks: the tasks given as pairs composed of an origin and a length
    :param origins: the origins of the tasks
    :param lengths: the lengths of the tasks
    :param zero_ignored: if True, the tasks with length 0 must be discarded
    :return: a constraint NoOverlap
    """
    ...

def Cumulative(tasks=..., *, origins=..., lengths=..., ends=..., heights=..., condition=...): # -> ConstraintDummyConstant | Variable | ECtr | PartialConstraint:
    """
    Builds and returns a component Cumulative (that becomes a constraint when subject to a condition).
    Either the tasks are specified as tuples of size 3 or 4, or the tasks are given by the name parameters
    origins, lengths and heights (and possibly ends).

    :param tasks:
    :param origins: the origins of the tasks
    :param lengths: the lengths of the tasks
    :param ends: the ends of the tasks (typically, None)
    :param heights: the heights (amounts of resource consumption) of the tasks
    :param condition: a condition directly specified for the Cumulative (typically, None)
    :return: a component/constraint Cumulative
    """
    ...

def BinPacking(partition, *partition_complement, sizes, limits=..., loads=..., condition=...): # -> ECtr | PartialConstraint:
    """
    Builds and returns a component BinPacking that:
      - either is directly a constraint when capacities (limits or loads) are given
      - or becomes a constraint when subject to a condition (specified outside the function)
    Capacities can be given by integers or variables, by specifying either limits or loads.
    When capacities are absent (both limits and loads being None), BinPacking is a component
    that must be subject to a condition, typically '<= k' where k is a value used as the same limit for all bins.

    :param partition: the (first) term, typically a list of variables, on which the component applies (indicating how the items are partitioned into bins)
    :param partition_complement: the other terms (if any) on which the component applies
    :param sizes: the sizes of the available items
    :param limits: the limits of bins (if loads is None)
    :param loads: the loads of bins (if limits is None)
    :param condition: a condition directly specified for the BinPacking (typically, None)
    :return: a component/constraint BinPacking
    """
    ...

def Knapsack(selection, *selection_complement, weights, wlimit=..., wcondition=..., profits, pcondition=...): # -> ECtr | PartialConstraint:
    """
    Builds and returns a component Knapsack that must guarantee that a condition holds wrt the capacity of the knapsack
    (when considering accumulated weights of selected items) and another condition holds wrt the profits.
    The second condition is typically specified outside the function which then represents ("returns")
    the accumulated profits of selected items.
    One has to specify either wlimit or wcondition.

    :param selection: the (first) term, typically a list of variables on which the component applies (indicating how many copies of each item is selected)
    :param selection_complement: the other terms (if any) on which the component applies
    :param weights: the weights associated with the items
    :param wlimit: the limit of the knapsack (if wcondition is None)
    :param wcondition: the condition on the knapsack (if wlimit is None)
    :param profits: the benefits associated with the items
    :param pcondition: a condition on the profits directly specified for the Knapsack (typically, None)
    :return: a component/constraint Knapsack
    """
    ...

def Flow(term, *others, balance, arcs, weights=..., condition=...): # -> ECtr | PartialConstraint:
    ...

def Circuit(successors, *successors_complement, start_index=..., size=...): # -> ECtr:
    """
    Builds and returns a constraint Circuit.

    :param successors: the (first) term on which the constraint applies (indicating the successors of variables)
    :param successors_complement: the other terms (if any) on which the constraint applies
    :param start_index: the number used for indexing the first variable/node in the list of terms
    :param size: the size of the circuit (a constant, a variable or None)
    :return: a constraint Circuit
    """
    ...

def Clause(variables, *variables_complement, phases=...): # -> ECtr:
    """
        Builds and returns a constraint Clause.

        :param variables: the first term on which the constraint applies
        :param variables_complement: the other terms (if any) on which the constraint applies
        :param phases: the phase of the variables involved in the clause
        :return: a constraint Clause
        """
    ...

def Adhoc(form, note=..., **d): # -> ECtr:
    """
    Builds a constraint adhoc from the specified arguments.

    :param form: a label (string) indicating the form of the adhoc constraint
    :note: a comment
    :d: a dictionary with all arguments of the adhoc constraint
    :return: a constraint Hadhoc
    """
    ...

def minimize(term): # -> EObjective:
    """
    Builds and returns an objective that corresponds to minimizing the specified term.
    This term can be a variable, an expression, a component Sum, Count, NValues, Maximum, Minimum, etc.

    :param term: the term to be minimized
    :return: the objective to be minimized
    """
    ...

def maximize(term): # -> EObjective:
    """
    Builds and returns an objective that corresponds to maximizing the specified term.
    This term can be a variable, an expression, a component Sum, Count, NValues, Maximum, Minimum, etc.

    :param term: the term to be maximized
    :return: the objective to be maximized
    """
    ...

def annotate(*, decision=..., output=..., varHeuristic=..., valHeuristic=..., filtering=..., prepro=..., search=..., restarts=...): # -> list[Any]:
    ...

def posted(i=..., j=...): # -> ListCtr | list[Any]:
    """
    Returns the list of posted constraints when no parameter is specified.
    Returns the constraints of the ith posted operation, otherwise; possibly
    a subset is returned if teh second parameter j is specified.

    :param i: the number/index of the posting operation (i.e., call to satisfy())
    :param j: the number (or slice) of the constraint wrt the ith posting operation
    """
    ...

def objective(): # -> None:
    """
    Returns the objective of the model, or None if no one has been defined by calling either the function minimize() or the function maximize()
    """
    ...

def unpost(i=..., j=...): # -> None:
    """
    If no parameter is specified, discards the last posting operation (call to satisfy).
    If two parameters are specified, discards the constraint(s) whose index(es) is specified
    by the second argument j (possibly a slice) inside the posting operation whose index is specified by the first parameter.
    If one parameter is specified, discards the posting operation whose index is specified,
    except if the constant ALL is used, in which case all posted constraints are discarded.

    :param i: the index of the posting operation (call to satisfy) to be discarded (if j is None)
    :param j: the index (or slice) of the constraint(s) to be removed inside the group of constraints
              corresponding to the specified posting operation
    """
    ...

def value(x, *, sol=...):
    """
    Returns the value assigned to the specified variable when the solution at the specified index has been found

    :param x: a variable
    :param sol: the index of a found solution
    """
    ...

def values(m, *, sol=...): # -> ListInt | None:
    """
    Returns a list similar to the specified structure with the values assigned to the involved variables
    when the solution at the specified index has been found

    :param m: a structure (typically list) of any dimension involving variables
    :param sol: the index of a found solution
    """
    ...

