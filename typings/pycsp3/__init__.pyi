"""
This type stub file was generated by pyright.
"""

import atexit
import os
import sys
from collections import namedtuple
from itertools import permutations, product
from pycsp3.functions import Adhoc, AllDifferent, AllDifferentList, AllEqual, AllEqualList, AllHold, And, AnyHold, AtLeastOne, AtMostOne, BinPacking, Cardinality, Channel, Circuit, Clause, Count, Cumulative, Decreasing, ExactlyOne, Exist, Flow, Hamming, If, Iff, Increasing, Knapsack, LexDecreasing, LexIncreasing, Match, Maximum, MaximumArg, Minimum, MinimumArg, NValues, NoOverlap, NoneHold, Not, NotAllEqual, NotExist, NumberDistinctValues, Or, Precedence, Product, Regular, Slide, Sum, Table, Var, VarArray, Xor, abs, annotate, belong, both, col, conjunction, disjunction, either, expr, iff, ift, imply, max, maximize, min, minimize, not_belong, objective, posted, protect, satisfy, subvariant, unpost, value, values, var, variant, xor
from pycsp3.tools.curser import columns, cp_array, diagonal_down, diagonal_up, diagonals_down, diagonals_up, ring
from pycsp3.tools.utilities import ALL, ANY, all_primes, alphabet_positions, combinations, decrement, different_values, flatten, integer_scaling, warning
from pycsp3.classes.auxiliary.conditions import complement, eq, ge, gt, le, lt, ne
from pycsp3.classes.auxiliary.enums import TypeRank, TypeSolver, TypeStatus
from pycsp3.classes.auxiliary.tables import to_ordinary_table
from pycsp3.classes.entities import clear
from pycsp3.classes.auxiliary.diagrams import Automaton, MDD
from pycsp3.compiler import Compilation, default_data, load_json_data

__python_version__ = ...
__pycsp3_version__ = ...
if sys.version_info[0] < 3 or sys.version_info[1] < 6:
    ...
if sys.version_info[1] < 9:
    ...
UNSAT = ...
SAT = ...
OPTIMUM = ...
CORE = ...
UNKNOWN = ...
ACE = ...
CHOCO = ...
Task = ...
if sys.argv:
    ...
_solver = ...
def solver(name=...): # -> Choco | Ace | None:
    """
    With no argument (name being None), the function returns the current solver (the last one that has been built).
    With an argument (name not being None), the function builds the solver whose name is specified, and returns it.

    :param name: the name of the solver to be built, or None (by default)
    :return: either the current solver if the specified name is None, or a newly created solver whose name is specified
    """
    ...

def compile(filename=..., *, verbose=...): # -> tuple[Any, Any]:
    """
    Compiles the current model

    :param filename: the filename of the compiled problem instance
    :param verbose: verbosity level from -1 to 2
    :return: a pair composed of a string (filename) and a Boolean (True if a COP, False otherwise)
    """
    ...

def status(): # -> TypeStatus | None:
    """
    Returns the status of the last solving operation, or None
    """
    ...

def solution(): # -> None:
    """
    Returns a complex object corresponding to the last found solution, or None
    """
    ...

def n_solutions(): # -> None:
    """
    Returns the number of solutions found by the last solving operation, or None
    """
    ...

def bound(): # -> None:
    """
    Returns the bound found by the last solving operation, or None
    """
    ...

def core(): # -> None:
    """
    returns the core identified by the last extraction operation, or None
    """
    ...

def solve(*, solver=..., options=..., filename=..., verbose=..., sols=..., extraction=...): # -> Literal[TypeStatus.UNKNOWN, TypeStatus.CORE, TypeStatus.UNSAT, TypeStatus.OPTIMUM, TypeStatus.SAT] | None:
    """
    Solves the current model (after compiling it) and returns the status of this operation.

    :param solver: name of the solver (ACE or CHOCO), possibly accompanied by general options
                   as defined in https://github.com/xcsp3team/pycsp3/blob/master/docs/optionsSolvers.pdf
    :param options: specific options for the solver
    :param filename: the filename of the compiled problem instance
    :param verbose: verbosity level from -1 to 2
    :param sols: number of solutions to be found (ALL if no limit)
    :param extraction: True if an unsatisfiable core of constraints must be sought
    :return: the status of the solving operation
    """
    ...

@atexit.register
def end(): # -> None:
    ...

