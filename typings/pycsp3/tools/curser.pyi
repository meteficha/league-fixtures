"""
This type stub file was generated by pyright.
"""

queue_in = ...
unsafe_cache = ...
def cursing(): # -> None:
    ...

class OpOverrider:
    activated = ...
    array_indexing_warning = ...
    @staticmethod
    def enable(): # -> None:
        ...
    
    @staticmethod
    def disable(): # -> type[OpOverrider]:
        ...
    
    @staticmethod
    def eq_protected(v1, v2): # -> bool:
        ...
    
    @staticmethod
    def execute(arg):
        ...
    
    @staticmethod
    def project_recursive(t, indexes, dimension): # -> ListInt | ListVar | ListCtr | ListMix | list[Any]:
        ...
    
    def __neg__(self): # -> Node:
        ...
    
    def __add__(self, other): # -> Self | <subclass of OpOverrider* and Node> | PartialConstraint | Node | Any:
        ...
    
    def __radd__(self, other): # -> Node:
        ...
    
    def __sub__(self, other): # -> Self | <subclass of OpOverrider* and Node> | PartialConstraint | Node | Any:
        ...
    
    def __rsub__(self, other): # -> Node:
        ...
    
    def __mul__(self, other): # -> Node:
        ...
    
    def __rmul__(self, other): # -> Node:
        ...
    
    def __mod__(self, other): # -> Node:
        ...
    
    def __pow__(self, other): # -> Node:
        ...
    
    def __floordiv__(self, other): # -> Node:
        ...
    
    def __rfloordiv__(self, other): # -> Node:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __le__(self, other) -> bool:
        ...
    
    def __ge__(self, other) -> bool:
        ...
    
    def __gt__(self, other) -> bool:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __or__(self, other): # -> Self | EOr | ConstraintDummyConstant | Node | Literal[True]:
        ...
    
    def __and__(self, other): # -> Self | EAnd | ConstraintDummyConstant | Literal[False]:
        ...
    
    def __invert__(self): # -> ENot | Variable | Node:
        ...
    
    def __xor__(self, other): # -> EXor | Node | ConstraintDummyConstant:
        ...
    
    def __rshift__(self, other): # -> list[Any | list[Any] | EOr | ConstraintDummyConstant | Node | EIfThen | EIfThenElse | None] | EOr | ConstraintDummyConstant | Node | EIfThen | EIfThenElse | list[Any] | None:
        ...
    


class ListInt(list):
    def __init__(self, integers) -> None:
        ...
    
    def __getslice__(self, i, j): # -> ListInt:
        ...
    
    def __add__(self, other): # -> ListInt:
        ...
    
    def __mul__(self, other): # -> int | ScalarProduct:
        ...
    
    def __rmul__(self, other): # -> int | ScalarProduct:
        ...
    
    def __contains__(self, other): # -> bool:
        ...
    
    def __str__(self) -> str:
        ...
    


class ListVar(list):
    def __init__(self, variables=...) -> None:
        ...
    
    def __getslice__(self, i, j): # -> ListVar:
        ...
    
    def __add__(self, other): # -> ListVar:
        ...
    
    def __mul__(self, other): # -> ScalarProduct:
        ...
    
    def __contains__(self, other): # -> bool:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __le__(self, other) -> bool:
        ...
    
    def __ge__(self, other) -> bool:
        ...
    
    def __gt__(self, other) -> bool:
        ...
    
    def at_border(self, i, j): # -> bool:
        ...
    
    def around(self, i, j): # -> ListVar:
        ...
    
    def beside(self, i, j): # -> ListVar:
        ...
    
    def cross(self, i, j): # -> ListVar:
        ...
    
    def __str__(self) -> str:
        ...
    


class ListCtr(list):
    def __init__(self, ectrs) -> None:
        ...
    
    def __getitem__(self, k): # -> ListCtr:
        ...
    
    def __str__(self) -> str:
        ...
    


class ListMix(list):
    def __init__(self, elements) -> None:
        ...
    
    def __getitem__(self, k):
        ...
    
    def __str__(self) -> str:
        ...
    


def convert_to_namedtuples(obj): # -> list[Any] | ListInt | ListVar | list[pycsp3.tools.curser.namedtuple] | pycsp3.tools.curser.namedtuple:
    ...

def is_namedtuple(obj): # -> bool:
    ...

def columns(m): # -> ListVar | ListInt | list[ListVar | ListInt | list[Any]]:
    """
    Returns the transpose matrix of the specified matrix

    :param m: a matrix (i.e. a two-dimensional list)
    :return: the transpose matrix
    """
    ...

def ring(matrix, k=...): # -> ListVar | ListInt | list[Any]:
    """
    Returns the kth ring of the specified matrix

    :param matrix:  a matrix (i.e. a two-dimensional list)
    :param k: the index of the ring (from the outside towards the inside, starting at 0)
    :return: the list of variables forming the kth ring of the specified matrix
    """
    ...

def diagonal_down(m, i=..., j=..., check=...): # -> ListVar | ListInt | list[Any]:
    """
    Returns the main downward diagonal, or another downward diagonal when the values
    of the parameters i and j are not both equal to -1

    :param m: a matrix (i.e. a two-dimensional list)
    :param i: index of row (possibly -1)
    :param j: index of column (possibly -1)
    :param check: true when the structure of the matrix must be controlled
    :return: the main downward diagonal (or another stipulated downward diagonal)
    """
    ...

def diagonals_down(m, *, broken=...): # -> ListVar | ListInt | list[Any | ListVar | ListInt | list[Any]]:
    """
    Returns the list of downward diagonals of the specified matrix

    :param m: a matrix (i.e. a two-dimensional list)
    :param broken: true when broken diagonals must be completed
    :return: the list of downward diagonals
    """
    ...

def diagonal_up(m, i=..., j=..., check=...): # -> ListVar | ListInt | list[Any]:
    """
       Returns the main upward diagonal, or another upward diagonal when the values
       of the parameters i and j are not both equal to -1

       :param m: a matrix (i.e. a two-dimensional list)
       :param i: index of row (possibly -1)
       :param j: index of column (possibly -1)
       :param check: true when the structure of the matrix must be controlled
       :return: the main upward diagonal (or another stipulated upward diagonal)
       """
    ...

def diagonals_up(m, *, broken=...): # -> ListVar | ListInt | list[Any | ListVar | ListInt | list[Any]]:
    """
      Returns the list of upward diagonals of the specified matrix

      :param m: a matrix (i.e. a two-dimensional list)
      :param broken: true when broken diagonals must be completed
      :return: the list of upward diagonals
      """
    ...

def cp_array(*t): # -> ListInt | ListVar | ListCtr | ListMix | list[Any]:
    """
    Converts and returns a list containing integers into a list from the more specific type ListInt.
    Converts and returns a list containing variables into a list from the more specific type ListVar.
    Returns the same list in all other cases.
    This method may be required for posting constraints Element.

    :param t: a list (of any dimension)
    :return: the same list, possibly converted into one of the two more specific types ListInt and ListVar
    """
    ...

